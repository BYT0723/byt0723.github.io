<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>golang-ants-tour</title>
    <link href="/20240705/golang-ants-tour/"/>
    <url>/20240705/golang-ants-tour/</url>
    
    <content type="html"><![CDATA[<h1 id="Ants"><a href="#Ants" class="headerlink" title="Ants"></a><a href="https://github.com/panjf2000/ants">Ants</a></h1><blockquote><p><strong><em>high-performance and low-cost goroutine pool</em></strong><br><strong><em>使用Golang编写的低成本高性能的goroutine池</em></strong></p></blockquote><h2 id="池子类型"><a href="#池子类型" class="headerlink" title="池子类型"></a>池子类型</h2><ul><li>Pool</li><li>PoolWithFunc</li><li>MultiPool</li><li>MultiPoolWithFunc</li></ul><h2 id="源码偶得自旋锁"><a href="#源码偶得自旋锁" class="headerlink" title="源码偶得自旋锁"></a>源码偶得自旋锁<a href="https://github.com/panjf2000/ants/blob/313f136d004dc2497fcc58b0d844fb7d068565b7/internal/sync/spinlock.go#L13"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Copyright 2019 Andy Pan &amp; Dietoad. All rights reserved.</span><br><span class="hljs-comment">// Use of this source code is governed by an MIT-style</span><br><span class="hljs-comment">// license that can be found in the LICENSE file.</span><br><br><span class="hljs-keyword">package</span> sync<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;runtime&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;sync/atomic&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> spinLock <span class="hljs-type">uint32</span><br><br><span class="hljs-keyword">const</span> maxBackoff = <span class="hljs-number">16</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sl *spinLock)</span></span> Lock() &#123;<br>backoff := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> !atomic.CompareAndSwapUint32((*<span class="hljs-type">uint32</span>)(sl), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// Leverage the exponential backoff algorithm, see https://en.wikipedia.org/wiki/Exponential_backoff.</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; backoff; i++ &#123;<br>runtime.Gosched()<br>&#125;<br><span class="hljs-keyword">if</span> backoff &lt; maxBackoff &#123;<br>backoff &lt;&lt;= <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sl *spinLock)</span></span> Unlock() &#123;<br>atomic.StoreUint32((*<span class="hljs-type">uint32</span>)(sl), <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-comment">// NewSpinLock instantiates a spin-lock.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSpinLock</span><span class="hljs-params">()</span></span> sync.Locker &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span>(spinLock)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两个关键点"><a href="#两个关键点" class="headerlink" title="两个关键点"></a>两个关键点</h3><ul><li>指数避让</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> backoff &lt; maxBackoff &#123;<br>  backoff &lt;&lt;= <span class="hljs-number">1</span>  <span class="hljs-comment">// 当小于最大避让次数，左移一位(即为2^(n+1))</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>runtime.Gosched</code><blockquote><p>runtime.Gosched() 是一个用于让出当前 goroutine 的调度器，以便让其他 goroutine 运行的函数。它不会明确指定让出 CPU 的时间，而是将当前 goroutine 放回到调度队列中，允许 Go 调度器选择运行其他可运行的 goroutine。实际上，它让出的是调度机会，而不是具体的时间片。</p><ul><li>让出调度：当前 goroutine 将自己放回到调度队列中，并且可能会立即被重新调度运行，或者在其他 goroutine 运行之后再被调度运行。</li><li>不阻塞：runtime.Gosched() 不会阻塞当前 goroutine，而是让出调度之后继续执行。</li></ul></blockquote></li></ul><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>time.Sleep 与 runtime.Gosched 的对比</p><ul><li>time.Sleep:<ul><li>让出 CPU 时间片并进入睡眠状态，直到指定的时间结束。</li><li>睡眠时间可以非常短（如 time.Nanosecond），也可以比较长。</li><li>在睡眠期间，该 goroutine 不会被调度运行。</li></ul></li><li>runtime.Gosched:<ul><li>立即让出当前 goroutine 的调度权，但没有指定具体的时间。</li><li>当前 goroutine 会被放回调度队列，调度器可以立即或者稍后重新调度该 goroutine。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
      <category>Goroutine Pool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Goroutine</tag>
      
      <tag>Pool</tag>
      
      <tag>Ants</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go内存对齐：结构体中0字节字段填充</title>
    <link href="/20240310/golang-memory-align-zeroBytes-padding/"/>
    <url>/20240310/golang-memory-align-zeroBytes-padding/</url>
    
    <content type="html"><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><p>观看以下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> S1 <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-keyword">struct</span>&#123;&#125;<br>b <span class="hljs-type">int8</span><br>c <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-keyword">type</span> S2 <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">int8</span><br>b <span class="hljs-type">int64</span><br>c <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>s1 S1<br>s2 S2<br>)<br>fmt.Printf(<span class="hljs-string">&quot;unsafe.Sizeof(s1): %v\n&quot;</span>, unsafe.Sizeof(s1))<br>fmt.Printf(<span class="hljs-string">&quot;unsafe.Sizeof(s2): %v\n&quot;</span>, unsafe.Sizeof(s2))<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-1-分析"><a href="#1-1-分析" class="headerlink" title="1.1 分析"></a>1.1 分析</h5><ul><li><p>S1</p><ol><li>a字段为<code>struct&#123;&#125;</code>,不占内存，0字节</li><li>b字段为<code>int8</code>,对齐长度1, 占1字节</li><li>c字段为<code>int64</code>,对齐长度8,前两个字段只占用了1字节，所以填充7字节，对齐到八字节位</li></ol><p>所以S1占用16字节</p></li><li><p>S2</p><ol><li>a字段为<code>int8</code>,对齐长度1, 占1字节</li><li>b字段为<code>int64</code>,对齐长度8,a字段只占用了1字节，所以填充7字节，对齐到八字节位</li><li>a字段为<code>struct&#123;&#125;</code>,不占内存，0字节</li></ol><p>所以S2占用16字节</p></li></ul><p><strong>真的对吗？</strong>,看看输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">unsafe</span>.Sizeof(s1): <span class="hljs-number">16</span><br><span class="hljs-attribute">unsafe</span>.Sizeof(s2): <span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p>为什么呢？我们看看golang仓库中的这个<a href="https://github.com/golang/go/issues/9401">issue 9401</a>,建议自己看比较好。</p><p>机翻一下<br><img src="https://i.imgur.com/K3SgHlB.png" alt="issue9401"><br>那么当0字符字段在结构体最后时，多出的一个结构体对齐长度，是为了防止结构体指针之乡结构体外部，即无效指针。</p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Memory Align</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>archlinux-wine-wechat-install</title>
    <link href="/20240310/archlinux-wine-wechat-install/"/>
    <url>/20240310/archlinux-wine-wechat-install/</url>
    
    <content type="html"><![CDATA[<blockquote><p>😅现在腾讯已推出wechat for linux, 使用yay或其他包管理工具从aur中安装wechat即可</p></blockquote><h3 id="1-安装方案"><a href="#1-安装方案" class="headerlink" title="1. 安装方案"></a>1. 安装方案</h3><ul><li><code>wine-for-wechat</code>配合<code>wine-wechat-setup</code>无脑爽,这是archlinuxcn源中的包</li></ul><h3 id="2-准备"><a href="#2-准备" class="headerlink" title="2. 准备"></a>2. 准备</h3><h4 id="2-1-ArchlinuxCN源配置"><a href="#2-1-ArchlinuxCN源配置" class="headerlink" title="2.1 ArchlinuxCN源配置"></a>2.1 ArchlinuxCN源配置</h4><p>根据<a href="https://wiki.archlinux.org/title/Unofficial_user_repositories#archlinuxcn">archlinuxcn</a>完成archlinuxcn源配置，然后使用<code>sudo pacman -Syu</code>更新源</p><h4 id="2-2-下载Wechat安装包"><a href="#2-2-下载Wechat安装包" class="headerlink" title="2.2 下载Wechat安装包"></a>2.2 下载Wechat安装包</h4><p>下载最新的<a href="https://pc.weixin.qq.com/">wechat 64位</a>安装包</p><span id="more"></span><h4 id="2-3-下载riched20-dll"><a href="#2-3-下载riched20-dll" class="headerlink" title="2.3 下载riched20.dll"></a>2.3 下载riched20.dll</h4><p>下载<a href="https://www.dll-files.com/download/5681d07a869a1a11020f7d28f7d621e2/riched20.dll.html">riched20.dll</a>,安装最新的64版本<br><img src="https://i.imgur.com/W435LZd.png" alt="riched20 x64"></p><h3 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h3><ul><li>安装wine和所需环境<blockquote><p><code>sudo pacman -S wine-for-wechat wine-wechat-setup wine-gecko winetricks wine-mono</code></p></blockquote></li><li>为wine容器安装fakechinese字体，如果不安装，你会看到方块字<blockquote><p><code>WINEPREFIX=~/.local/lib/wine-wechat/default winetricks fakechinese</code></p></blockquote></li><li>安装新的riched20.dll<ol><li>备份旧的<code>riched20.dll</code><blockquote><p><code>mv ~/.local/lib/wine-wechat/default/drive_c/windows/system32/riched20.dll ~/.local/lib/wine-wechat/default/drive_c/windows/system32/riched20_old.dll</code></p></blockquote></li><li>解压zip文件<br>如果没有unzip,使用<code>sudo pacman -S unzip</code>安装一下<blockquote><p><code>unzip riched20.zip</code></p></blockquote></li><li>将新的dll文件放入system32中<blockquote><p><code>cp riched20.dll ~/.local/lib/wine-wechat/default/drive_c/windows/system32/</code></p></blockquote></li></ol></li><li>安装wechat<blockquote><p><code>wechat -i &lt;wechat安装包路径&gt;</code></p></blockquote></li></ul><h3 id="4-剩余问题"><a href="#4-剩余问题" class="headerlink" title="4.剩余问题"></a>4.剩余问题</h3><ul><li>设置页面的字体还是有方块<br><img src="https://i.imgur.com/Gf3yy1T.png" alt="setting"></li><li>订阅号的内容无法展示</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Arch</tag>
      
      <tag>Wine</tag>
      
      <tag>Wechat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go优雅重启</title>
    <link href="/20231126/golang-stateful-rolling-restart/"/>
    <url>/20231126/golang-stateful-rolling-restart/</url>
    
    <content type="html"><![CDATA[<h4 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h4><p>例如当我们更新了配置文件，但是我们不想停止程序重启</p><h4 id="2-实现思想"><a href="#2-实现思想" class="headerlink" title="2. 实现思想"></a>2. 实现思想</h4><p>在我们检测到配置文件更改时，进行进程替换，但如果我们开启子进程，杀死父进程，会产生孤儿进程</p><span id="more"></span><h4 id="3-破局"><a href="#3-破局" class="headerlink" title="3. 破局"></a>3. 破局</h4><p>查询资料，发现了<code>syscall.Exec</code>函数，文档中这样描写到<code>Exec invokes the execve(2) system call.</code>，那么这个<code>execve(2)</code>的系统调用有什么作用呢？</p><blockquote><p>execve() executes the program referred to by pathname. This causes the program that is currently being run by the calling process to be replaced with a new program, with newly initialized stack, heap, and (initialized and uninitialized) data segments.<br>翻译一下：<br>execve() 执行路径名引用的程序。 这会导致当前正在由调用进程运行的程序被新程序替换，新程序具有新初始化的堆栈、堆和（已初始化和未初始化的）数据段。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;syscall&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := syscall.Exec(<span class="hljs-string">&quot;/bin/ls&quot;</span>, []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-l&quot;</span>, <span class="hljs-string">&quot;-a&quot;</span>&#125;, os.Environ()); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;syscall.Exec报错了: &quot;</span>, err.Error())<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;我还没上车呢。。。。&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/djwXFwO.png" alt="output1"><br><img src="https://i.imgur.com/dVbXoQf.png" alt="output2"></p><p>可以发现，当我们成功执行<code>syscall.Exec</code>时，我们的程序被替换成了<code>ls -al</code>，所以最后一行输出语句并没有执行</p><hr><p>chatgpt对于<code>syscall.Exec</code>的回答<br><img src="https://imgur.com/ZXAvDht.png" alt="chatgpt syscall exec"></p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>note</title>
    <link href="/20231106/note/"/>
    <url>/20231106/note/</url>
    
    <content type="html"><![CDATA[<h3 id="本文以及评论记录了平时的一些问题"><a href="#本文以及评论记录了平时的一些问题" class="headerlink" title="本文以及评论记录了平时的一些问题"></a>本文以及评论记录了平时的一些问题</h3><ul><li><a href="https://github.com/BYT0723/music-downloader">music-downloader</a><blockquote><ul><li>music-downloader的歌曲名还是会出现字符错误，继续排查</li><li>DONE: qq-music-api中没有check是否获取到歌词</li></ul></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>common</category>
      
    </categories>
    
    
    <tags>
      
      <tag>common</tag>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arch安装Dwm</title>
    <link href="/20230610/archlinux-xorg-dwm/"/>
    <url>/20230610/archlinux-xorg-dwm/</url>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>你需要确保你已经安装好了 Arch 或其他发行版的 Linux,并且已经接入互联网、配置好了你的 <code>pacman.conf</code> 和 <code>mirrorlist</code></p><blockquote><p>Tips: 如果您已接触过其他桌面管理器，可直接跳转至<a href="#4%E5%AE%89%E8%A3%85">安装</a></p></blockquote><h3 id="2-安装-Xorg"><a href="#2-安装-Xorg" class="headerlink" title="2.安装 Xorg"></a>2.安装 Xorg</h3><p>Xorg （通常简称为 X ）是 Linux 用户中最流行的显示服务器。 它无处不在，使其成为 GUI 应用程序永远存在的必要条件，从而导致大多数发行版的大量采用。<a href="https://wiki.archlinux.org/title/Xorg">wiki</a><br>xorg 是 dwm 乃至大多数桌面环境的基础(hyprrland 除外).</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S xorg xorg-server xorg-apps<br></code></pre></td></tr></table></figure><blockquote><p>xorg-apps 中包括了很多有用的工具，例如<code>xrandr</code>、<code>xprop</code>、<code>xmodmap</code>、<code>xsetroot</code></p></blockquote><span id="more"></span><h3 id="3-驱动安装"><a href="#3-驱动安装" class="headerlink" title="3.驱动安装"></a>3.驱动安装</h3><ol><li>显卡</li></ol><ul><li>intel <code>xf86-video-intel</code></li><li>amd <code>xf86-video-amdgpu</code></li><li>nvidia <code>nvidia-dkms</code></li></ul><ol start="2"><li>输入设备</li></ol><ul><li><code>xf86-input-libinput</code></li><li>触摸板<code>xf86-input-synaptics</code></li></ul><p>这是配置均可在<code>/etc/X11/xorg.conf.d/</code>下配置,细见<a href="https://wiki.archlinux.org/title/Xorg#Input_devices">xorg wiki</a>,根据输入设备分类，查看 wiki 进行配置</p><blockquote><p>默认可不配置，在启动后发现设备不可用再配置也可</p></blockquote><h3 id="4-安装"><a href="#4-安装" class="headerlink" title="4.安装"></a>4.安装</h3><h4 id="4-1-安装-Dwm"><a href="#4-1-安装-Dwm" class="headerlink" title="4.1 安装 Dwm"></a>4.1 安装 Dwm</h4><blockquote><p>Tips: 如果你安装的过程中需要大量使用 github 或国外的资源，建议先安装并配置好系统代理.</p></blockquote><ul><li>从 suckless.org 从拉取最新的 dwm</li><li>使用现成的<a href="https://github.com/BYT0723/dwm">github</a>或<a href="https://gitee.com/BYT0723/dwm">gitee</a></li></ul><p>因为我的现成的,所以我选择现成的.如果你一次接触 Dwm 或平铺式窗口管理器，建议使用最新的 Dwm,然后去安装补丁，或自主修改，虽然使用过程会曲折一些，但你会更加得心应手</p><ol><li>拉取 Dwm</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/BYT0723/dwm.git<br><span class="hljs-meta prompt_"># </span><span class="language-bash">无法访问github的朋友可</span><br>git clone https://gitee.com/BYT0723/dwm.git<br></code></pre></td></tr></table></figure><ol start="2"><li>编译安装</li></ol><blockquote><p>Tips: 此步操作需要<code>make</code>,如果没有的朋友可使用包管理工具进行安装</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd dwm<br>sudo make clean install<br></code></pre></td></tr></table></figure><p>dwm 将会被安装到<code>/usr/local/bin/</code>下</p><h4 id="4-2-终端安装"><a href="#4-2-终端安装" class="headerlink" title="4.2 终端安装"></a>4.2 终端安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/BYT0723/st.git<br><span class="hljs-meta prompt_"># </span><span class="language-bash">无法访问github的朋友可</span><br>git clone https://gitee.com/BYT0723/st.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">以及</span><br>sudo pacman -S alacritty<br></code></pre></td></tr></table></figure><p>共安装了两个终端<code>st</code>和<code>alacritty</code>,st 和 dwm 更配，但最令人窒息的就是窗口大小改变时内容会丢失;alacritty 是 rust 编写的，并使用了 gpu 加速，速度更快.<br>在我的 Dwm 配置中 st 提供浮动终端，而 alacritty 供日常使用。alacritty 没有连字功能,st 有连字功能.</p><h4 id="4-3-脚本安装"><a href="#4-3-脚本安装" class="headerlink" title="4.3 脚本安装"></a>4.3 脚本安装</h4><blockquote><p>Dwm 中涉及较多的 shell 脚本，当然还有其他实现方法，各位可自行探索</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/BYT0723/scripts.git ~/.dwm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">无法访问github的朋友可</span><br>git clone https://gitee.com/BYT0723/scripts.git ~/.dwm<br></code></pre></td></tr></table></figure><blockquote><p>重点：查看<code>~/.dwm/README.md</code>, 安装好所有需要的依赖和字体等，会让你有一个较好的启动体验</p></blockquote><h3 id="5-启动"><a href="#5-启动" class="headerlink" title="5.启动"></a>5.启动</h3><p>以下两种任选其一</p><h4 id="5-1-使用-startx"><a href="#5-1-使用-startx" class="headerlink" title="5.1 使用 startx"></a>5.1 使用 startx</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">如果你的~/.xinitrc文件不存在或内容为空</span><br>echo &quot;exec dwm &gt;&gt; ~/.dwm.log&quot; &gt; .xinitrc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">否则</span><br>echo &quot;exec dwm &gt;&gt; ~/.dwm.log&quot; &gt;&gt; .xinitrc<br></code></pre></td></tr></table></figure><p>之后在<code>$HOME</code>目录下执行<code>startx</code>即可</p><h4 id="5-2-使用启动管理器"><a href="#5-2-使用启动管理器" class="headerlink" title="5.2 使用启动管理器"></a>5.2 使用启动管理器</h4><p>经过本人使用，双显卡用户使用 optimius-manager 配合启动管理器效果更佳. 配置更轻便简单</p><ol><li>安装 lightdm</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S lightdm lightdm-gtk-greeter lightdm-gtk-greeter-setting<br></code></pre></td></tr></table></figure><ol start="2"><li>配置 lightdm</li></ol><p>配置 greeter,看清，是<code>[Seat:*]</code>下的配置,将对应的配置项修改为如下值</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Seat:*]</span><br><span class="hljs-attr">greeter-session</span>=lightdm-gtk-greeter<br></code></pre></td></tr></table></figure><ol start="3"><li>添加 Dwm</li></ol><p>将如下如内容添加到<code>/usr/share/xsessions/dwm.desktop</code>中并保存</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Desktop Entry]</span><br><span class="hljs-attr">Type</span>=XSession<br><span class="hljs-attr">Exec</span>=/usr/local/bin/dwm<br><span class="hljs-attr">TryExec</span>=/usr/local/bin/dwm<br><span class="hljs-attr">DesktopNames</span>=Dwm<br><span class="hljs-attr">Name</span>=Dwm<br><span class="hljs-attr">Comment</span>=Dynamic Window Manager<br></code></pre></td></tr></table></figure><ol start="4"><li>启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开机启动</span><br>sudo systemctl enable lightdm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动</span><br>sudo systemctl start lightdm<br><br></code></pre></td></tr></table></figure><p>这样你就可看到管理器界面，登录即可进入 Dwm</p><h3 id="6-其他配置-可选"><a href="#6-其他配置-可选" class="headerlink" title="6. 其他配置(可选)"></a>6. 其他配置(可选)</h3><h4 id="6-1-配置xorg的keymap映射"><a href="#6-1-配置xorg的keymap映射" class="headerlink" title="6.1 配置xorg的keymap映射"></a>6.1 配置xorg的keymap映射</h4><p>编辑<code>/etc/X11/xorg.conf.d/00-keyboard.conf</code>文件，如果文件不存在则创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xf86conf">Section &quot;InputClass&quot;<br>        Identifier &quot;system-keyboard&quot;<br>        MatchIsKeyboard &quot;on&quot;<br>        Option &quot;XkbLayout&quot; &quot;us&quot;<br>        Option &quot;XkbModel&quot; &quot;pc104&quot;<br>        Option &quot;AutoRepeat&quot; &quot;250 50&quot;<br>        Option &quot;XkbOptions&quot; &quot;caps:swapescape,altwin:swap_lalt_lwin&quot;<br>EndSection<br></code></pre></td></tr></table></figure><p>解释：</p><ul><li><code>AutoRepeat</code>设置触键频率</li><li><code>XkbOptions</code>设置键盘键位切换，其中<code>caps:swapescape</code>代表交换大小写锁定和Esc, <code>altwin:swap_lalt_lwin</code>代表交换Logo键(Win)和左Alt键,<br>具体其他键位可查看<code>/usr/share/X11/xkb/rules/base.lst</code></li></ul><h4 id="6-2-配置系统代理"><a href="#6-2-配置系统代理" class="headerlink" title="6.2 配置系统代理"></a>6.2 配置系统代理</h4><p>见<a href="/20230315/archlinux-system-proxy/">ArchLinux系统代理</a>, 如果各位有其他的更优更简便的方案可补充</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Arch</tag>
      
      <tag>Linux</tag>
      
      <tag>Dwm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang_context</title>
    <link href="/20230526/golang-context/"/>
    <url>/20230526/golang-context/</url>
    
    <content type="html"><![CDATA[<p>部分初学者使用web框架时会发现每个handler都会传入一个context，但并没有深究他的作用，甚至直接传入一个<code>context.Background()</code>草草了事。本文结合我在工作中的实际场景，盘点下context的使用</p><h4 id="1-控制goroutine"><a href="#1-控制goroutine" class="headerlink" title="1. 控制goroutine"></a>1. 控制goroutine</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>daemon1()<br>&#125;()<br><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>daemon2()<br>&#125;()<br><br>wg.Wait()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">daemon1</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 开启8080端口tcp监听，并处理连接</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">daemon2</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 开启8080端口udp监听，并处理连接</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如上，我们在<code>main</code>函数中启动了两个守护协程，并使用<code>WaitGroup</code>等待goroutine结束，但由于daemon中监听并处理，一般有<code>for &#123;&#125;</code>结构，无法退出。当我们退出主协程，由于等待，会导致我们的程序卡死</p><span id="more"></span><h5 id="1-1-ctx-Done"><a href="#1-1-ctx-Done" class="headerlink" title="1.1 ctx.Done"></a>1.1 ctx.Done</h5><p>我们的诉求是在主协程退出时，子协程需要一起退出。代码做出如下修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;os/signal&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;syscall&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx, cancel := context.WithCancel(context.Background())<br><span class="hljs-comment">// 监听系统中断信号</span><br>exitCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">1</span>)<br>signal.Notify(exitCh, syscall.SIGINT, syscall.SIGTERM)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-exitCh<br>cancel()<br>&#125;()<br><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>daemon1(ctx)<br>&#125;(ctx)<br><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>daemon2(ctx)<br>&#125;(ctx)<br><br>wg.Wait()<br>log.Println(<span class="hljs-string">&quot;main 结束...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">daemon1</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 开启8080端口tcp监听，并处理连接</span><br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br><span class="hljs-comment">// 关闭连接和listener</span><br>log.Println(<span class="hljs-string">&quot;daemon1 结束...&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><span class="hljs-comment">// 处理连接</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">daemon2</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 开启8080端口udp监听，并处理连接</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br><span class="hljs-comment">// 关闭连接和listener</span><br>log.Println(<span class="hljs-string">&quot;daemon2 结束...&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><span class="hljs-comment">// 处理连接</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Tips: 在使用<code>context.WithTimeout</code>和<code>context.withDeadline</code>时，在超时后虽然<code>ctx.Done</code>会触发，但是这个channel并不会关闭，我们需要手动调用<code>cancel()</code>关闭这个<code>ctx.Done()</code>这个channel</p></blockquote><h4 id="2-携带参数"><a href="#2-携带参数" class="headerlink" title="2. 携带参数"></a>2. 携带参数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;os/signal&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;syscall&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ctx, cancel := context.WithCancel(context.Background())<br><br>ctx = context.WithValue(ctx, <span class="hljs-string">&quot;TCPHandlerName&quot;</span>, <span class="hljs-string">&quot;tcp-daemon&quot;</span>)<br>ctx = context.WithValue(ctx, <span class="hljs-string">&quot;UDPHandlerName&quot;</span>, <span class="hljs-string">&quot;udp-daemon&quot;</span>)<br><br><span class="hljs-comment">// 监听系统中断信号</span><br>exitCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">1</span>)<br>signal.Notify(exitCh, syscall.SIGINT, syscall.SIGTERM)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-exitCh<br>cancel()<br>&#125;()<br><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>daemon1(ctx)<br>&#125;(ctx)<br><br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>daemon2(ctx)<br>&#125;(ctx)<br><br>wg.Wait()<br>log.Println(<span class="hljs-string">&quot;main 结束...&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">daemon1</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 开启8080端口tcp监听，并处理连接</span><br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br><span class="hljs-comment">// 关闭连接和listener</span><br>log.Println(ctx.Value(<span class="hljs-string">&quot;TCPHandlerName&quot;</span>), <span class="hljs-string">&quot; 结束...&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><span class="hljs-comment">// 处理连接</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">daemon2</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 开启8080端口udp监听，并处理连接</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br><span class="hljs-comment">// 关闭连接和listener</span><br>log.Println(ctx.Value(<span class="hljs-string">&quot;UDPHandlerName&quot;</span>), <span class="hljs-string">&quot; 结束...&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><span class="hljs-comment">// 处理连接</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Tips: context的valule只能向子ctx传递，并且在网络中无法传递，如果您正在使用grpc，请考虑使用metadata</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>db_with_cache</title>
    <link href="/20230523/db-with-cache/"/>
    <url>/20230523/db-with-cache/</url>
    
    <content type="html"><![CDATA[<h3 id="1-DB-和-Cache-的数据一致性"><a href="#1-DB-和-Cache-的数据一致性" class="headerlink" title="1. DB 和 Cache 的数据一致性"></a>1. DB 和 Cache 的数据一致性</h3><ul><li><p><strong>延迟双删</strong></p></li><li><p><strong>binlog 异步更新</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>common</category>
      
    </categories>
    
    
    <tags>
      
      <tag>common</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>network-interview</title>
    <link href="/20230506/network-interview/"/>
    <url>/20230506/network-interview/</url>
    
    <content type="html"><![CDATA[<h3 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h3><h3 id="Grpc-和-HTTP1-1-应用场景的差别"><a href="#Grpc-和-HTTP1-1-应用场景的差别" class="headerlink" title="Grpc 和 HTTP1.1 应用场景的差别"></a>Grpc 和 HTTP1.1 应用场景的差别</h3><blockquote><p>gRPC 是一种高性能的 RPC（Remote Procedure Call）框架，它使用 Protocol Buffers 进行序列化和反序列化，支持多种编程语言，并提供了丰富的特性，如流式处理、认证和授权等。在微服务场景下，由于 gRPC 使用二进制协议进行通信，因此它的效率和吞吐量都比 RESTful API 更高。此外，gRPC 还提供了更加丰富的服务定义和代码生成工具，可以更加方便地生成客户端和服务器端的代码。<br>而 RESTful API 则是一种基于 HTTP 协议的 API 设计风格，它使用 JSON、XML 等文本格式进行序列化和反序列化，具有简单、灵活、易于理解和使用的特点。RESTful API 适用于基于 HTTP 的应用程序，比如 Web 应用程序、移动应用程序等，且可以跨语言和平台使用。在微服务场景下，RESTful API 具有更加广泛的应用场景，比如服务暴露、API 网关等。<br>因此，选择 gRPC 还是 RESTful API 需要根据具体需求和场景进行选择。如果需要高性能、高吞吐量的微服务之间通信，或者需要流式处理、认证和授权等高级特性，可以选择 gRPC；如果需要简单、灵活、易于理解和使用的 API，或者需要跨语言和平台使用，可以选择 RESTful API。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>string-algorithm</title>
    <link href="/20230506/string-algorithm/"/>
    <url>/20230506/string-algorithm/</url>
    
    <content type="html"><![CDATA[<blockquote><p>waiting to learn</p></blockquote><h3 id="1-字符串匹配算法（KMP）"><a href="#1-字符串匹配算法（KMP）" class="headerlink" title="1. 字符串匹配算法（KMP）"></a>1. 字符串匹配算法（KMP）</h3><h3 id="2-LIS（最长递增子序列）"><a href="#2-LIS（最长递增子序列）" class="headerlink" title="2. LIS（最长递增子序列）"></a>2. LIS（最长递增子序列）</h3><h3 id="3-LCS（最长公共子序列）"><a href="#3-LCS（最长公共子序列）" class="headerlink" title="3. LCS（最长公共子序列）"></a>3. LCS（最长公共子序列）</h3><h3 id="4-LCP（最长公共前缀）"><a href="#4-LCP（最长公共前缀）" class="headerlink" title="4. LCP（最长公共前缀）"></a>4. LCP（最长公共前缀）</h3><h3 id="5-LPS（最长回文子序列）"><a href="#5-LPS（最长回文子序列）" class="headerlink" title="5. LPS（最长回文子序列）"></a>5. LPS（最长回文子序列）</h3><h3 id="6-ED（最小编辑距离）"><a href="#6-ED（最小编辑距离）" class="headerlink" title="6. ED（最小编辑距离）"></a>6. ED（最小编辑距离）</h3>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>os-interview</title>
    <link href="/20230506/os-interview/"/>
    <url>/20230506/os-interview/</url>
    
    <content type="html"><![CDATA[<h3 id="1-同步和异步，阻塞和非阻塞"><a href="#1-同步和异步，阻塞和非阻塞" class="headerlink" title="1. 同步和异步，阻塞和非阻塞"></a>1. 同步和异步，阻塞和非阻塞</h3><h3 id="2-线程状态"><a href="#2-线程状态" class="headerlink" title="2. 线程状态"></a>2. 线程状态</h3><h3 id="3-什么是上下文切换"><a href="#3-什么是上下文切换" class="headerlink" title="3. 什么是上下文切换"></a>3. 什么是上下文切换</h3><h3 id="4-文件系统格式"><a href="#4-文件系统格式" class="headerlink" title="4. 文件系统格式"></a>4. 文件系统格式</h3><ol><li>类 Unix<br>ext</li></ol><ul><li>ext</li><li>ext2</li><li>ext3</li><li>ext4</li></ul><ol start="2"><li>DOM</li></ol><ul><li>FAT32</li></ul><p>传统的 windows 平台文件系统格式，兼容性强。<br>但 FAT32 不支持 4GB 以上的文件，并且没有日志，也就是断电后容易出现文件丢失的情况</p><ul><li>NTFS</li></ul>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql-interview</title>
    <link href="/20230506/sql-interview/"/>
    <url>/20230506/sql-interview/</url>
    
    <content type="html"><![CDATA[<h3 id="1-SQL-语句的执行流程"><a href="#1-SQL-语句的执行流程" class="headerlink" title="1. SQL 语句的执行流程"></a>1. SQL 语句的执行流程</h3><h4 id="1-1-逻辑剖析"><a href="#1-1-逻辑剖析" class="headerlink" title="1.1 逻辑剖析"></a>1.1 逻辑剖析</h4><blockquote><p>sql 语句 &gt; 查询缓存 &gt; 解释器 &gt; 优化器 &gt; 执行器</p></blockquote><h3 id="2-如何在生产环境中为表格增加字段"><a href="#2-如何在生产环境中为表格增加字段" class="headerlink" title="2. 如何在生产环境中为表格增加字段"></a>2. 如何在生产环境中为表格增加字段</h3><h3 id="3-事务"><a href="#3-事务" class="headerlink" title="3.事务"></a>3.事务</h3><h4 id="3-1-ACID"><a href="#3-1-ACID" class="headerlink" title="3.1 ACID"></a>3.1 ACID</h4><ul><li>Atomicity，原子操作</li><li>Consistency，一致性</li><li>Isolation，隔离性</li><li>Durability，持久性</li></ul><p>解释如下可能会用到 2~3 个事务，这里简称 ABC。</p><ul><li><p>脏写</p><ol><li>A 先将数据从 NULL 更新为 1</li><li>在 A 未提交时，B 将数据从 1 更新为 2</li><li>A 在执行过程中发生错误并回滚，将数据回滚为 NULL</li><li>B 提交后发现数据并不是 2，并且自己的事务并没有执行失败</li></ol><p>B 写失败了</p></li><li><p>脏读</p><ol><li>A 先将数据从 NULL 更新为 1</li><li>在 A 未提交时，B 读取数据为 1</li><li>A 在执行过程中发生错误并回滚，将数据回滚为 NULL</li><li>B 再次读取数据发现是 NULL</li></ol><p>B 在 step 2 时读取了脏数据</p></li></ul><blockquote><p>脏写和脏读类似，都是对<strong>未提交事务修改的数据</strong>进行操作，在该事务发生错误回滚后，就会导致脏写和脏读发生</p></blockquote><ul><li><p>不可重复读（update）<br>A 在执行过程中多次读取数据，但在执行过程中，B 和 C 修改并提交了数据，导致 A 多次读取读取到了不同的值</p></li><li><p>幻读（insert,delete）<br>A 在执行过程中多次查询数据，但在执行过程中，B 和 C 插入并提交新的数据，导致 A 多次查询，查到了不同条数的结果</p></li></ul><span id="more"></span><h4 id="3-2-事务隔离级别"><a href="#3-2-事务隔离级别" class="headerlink" title="3.2 事务隔离级别"></a>3.2 事务隔离级别</h4><ul><li><p>Read Uncommitted（读未提交）<br>顾名思义，事务可以读取到其他事务未提交的数据。会发生脏读、不可重复读和幻读。</p></li><li><p>Read Committed（读以提交）<br>事务无法读取到其他事务未提交的数据，杜绝脏读出现，但仍然会发生不可重复读和幻读。</p></li><li><p>Repeatable Read（可重复读）<br>MVCC(Multi-Version Concurrency Control)，多版本并发控制。事务开始时，会进行快照读，如果想读取新的数据，可进行当前读。当然这样会出现不可重复读和幻读的现象</p></li><li><p>Serializable（序列化）<br>事务按照顺序执行，需要的数据行或表都会被加锁</p></li></ul><h3 id="4-clickhouse-这种列式数据库和传统数据库的优劣"><a href="#4-clickhouse-这种列式数据库和传统数据库的优劣" class="headerlink" title="4. clickhouse 这种列式数据库和传统数据库的优劣"></a>4. clickhouse 这种列式数据库和传统数据库的优劣</h3><ol><li><p>clickhouse<br>优点：</p><ul><li>高效查询：列式数据库，可快速进行聚合查询、分析等，有较强的并发处理能力</li><li>可扩展性：clickhouse 可水平扩展，通过添加更多节点来扩展数据库的存储和处理能力</li></ul><p>缺点：</p><ul><li>数据更新操作相对较慢：不适合需要频繁进行数据更新的场景</li><li>不支持复杂的关系型数据库模型：由于是列式数据库，不支持传统的关系型数据库的数据模型</li></ul></li><li><p>mysql 等<br>优点：</p><ul><li>事务支持：传统关系型数据库有强大的事务支持，可以确保数据的一致性和可靠性</li><li>灵活性：支持复杂的查询和数据操作，可以满足各种不同的场景</li><li>成熟的生态系统：传统的关系型数据库有很多成熟的工具和框架，可以帮助开发人员进行开发、测试和部署。</li></ul><p>缺点：</p><ul><li>不太适合大数据场景：传统的关系型数据库通常不太适合处理大数据，会遇到性能瓶颈</li><li>可扩展性有限：传统数据库扩展性有点，需要进行垂直扩展即，增加更多的计算和存储资源，这会带来较高的成本。</li></ul></li></ol><h3 id="5-开窗函数"><a href="#5-开窗函数" class="headerlink" title="5. 开窗函数"></a>5. 开窗函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 排序</span><br><span class="hljs-built_in">row_number</span>() <span class="hljs-keyword">over</span>([<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> ...] [<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> ...])<br><span class="hljs-built_in">rank</span>()       <span class="hljs-keyword">over</span>([<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> ...] [<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> ...])<br><span class="hljs-built_in">dense_rank</span>() <span class="hljs-keyword">over</span>([<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> ...] [<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> ...])<br><br><span class="hljs-comment">-- 聚合</span><br><span class="hljs-built_in">count</span>() <span class="hljs-keyword">over</span>([<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> ...] [<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> ...])<br><span class="hljs-built_in">max</span>()   <span class="hljs-keyword">over</span>([<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> ...] [<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> ...])<br><span class="hljs-built_in">min</span>()   <span class="hljs-keyword">over</span>([<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> ...] [<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> ...])<br><span class="hljs-built_in">sum</span>()   <span class="hljs-keyword">over</span>([<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> ...] [<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> ...])<br><span class="hljs-built_in">avg</span>()   <span class="hljs-keyword">over</span>([<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> ...] [<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> ...])<br><br><span class="hljs-comment">-- 其它</span><br><span class="hljs-built_in">first_value</span>() <span class="hljs-keyword">over</span>([<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> ...] [<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> ...])<br><span class="hljs-built_in">last_value</span>()  <span class="hljs-keyword">over</span>([<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> ...] [<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> ...])<br><span class="hljs-built_in">lag</span>()         <span class="hljs-keyword">over</span>([<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> ...] [<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> ...])<br><span class="hljs-built_in">lead</span>()        <span class="hljs-keyword">over</span>([<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> ...] [<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> ...])<br></code></pre></td></tr></table></figure><ol><li>排序开窗函数</li></ol><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>row_number()</td><td>相同值排名顺延，结果<code>1,2,3,4</code></td></tr><tr><td>rank()</td><td>相同值排名相同，但不顺延，结果<code>1,2,2,4</code></td></tr><tr><td>dense_rank()</td><td>相同值排名相同，但结果顺延,结果<code>1,2,2,3</code></td></tr><tr><td>ntile(n)</td><td>将结果分为 n 组, 结果<code>1,1,2,2,...,n,n</code></td></tr></tbody></table><ol start="2"><li>聚合函数</li></ol><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>sum()</td><td>分组求和</td></tr><tr><td>count()</td><td>分组求总数</td></tr><tr><td>min()</td><td>分组求最小值</td></tr><tr><td>max()</td><td>分组求最大值</td></tr><tr><td>avg()</td><td>分组求平均值</td></tr></tbody></table><ol start="3"><li>其他函数</li></ol><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>lag(column,n,0)</td><td>返回 column 字段向上第 n 行数值，若不存在默认为第三个参宿，若第三个参数无，则默认为 null</td></tr><tr><td>lead(column,n,0)</td><td>同上，但是为向下偏移</td></tr><tr><td>first_value()</td><td>分组内排序后，截止目前行的第一个值</td></tr><tr><td>last_value()</td><td>分组内排序后，截止目前行的最后一个值</td></tr></tbody></table><h4 id="开窗实践"><a href="#开窗实践" class="headerlink" title="开窗实践"></a>开窗实践</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">......<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁</title>
    <link href="/20230504/lock/"/>
    <url>/20230504/lock/</url>
    
    <content type="html"><![CDATA[<h3 id="1-互斥锁和自旋锁"><a href="#1-互斥锁和自旋锁" class="headerlink" title="1. 互斥锁和自旋锁"></a>1. 互斥锁和自旋锁</h3><p>区别：</p><ul><li><p>互斥锁：在加锁失败后，线程会释放 CPU，给其他线程；<br>互斥锁在加锁失败时，会从<strong>用户态陷入到内核态</strong>，让内核帮我们切换线程，这样就会造成一定的性能开销。<br>线程在两次状态的切换中，会有<strong>两次线程<em>上下文切换</em></strong>。</p><blockquote><p>线程的上下文切换的是什么？当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</p></blockquote><ol><li>加锁失败时，将 CPU 让给其他线程</li><li>锁被释放时，线程会转换为[就绪]状态，内核会在合适时间将 CPU 切换回该线程</li></ol><p>有大佬统计过，大概在几十纳秒到几微秒之间。如果你能确定被锁住的代码执行时间很短，就应该选用自旋锁，否则使用互斥锁。</p></li><li><p>自旋锁：在加锁失败后，线程会忙等待，直到它拿到锁；<br>自旋锁是通过 CAS（Compare And Swap）函数，在用户态完成加锁和解锁，所以不会上下文切换的开销，相对于互斥锁更快，开销更小。</p></li></ul><span id="more"></span><h3 id="2-读写锁"><a href="#2-读写锁" class="headerlink" title="2. 读写锁"></a>2. 读写锁</h3><p>读锁是互斥锁，而写锁是共享锁，可以多个线程持有读锁，所以读写锁在<strong>读多写少</strong>的场景中更能发挥出优势</p><ul><li>读优先锁<br>在有线程持有读锁的情况下，当其他线程想获取读锁时，会持续获取读锁，写锁请求等待；当所有读锁释放时，写锁将会被持有。<blockquote><p>当持续有线程获取读锁，会导致写线程饥饿</p></blockquote></li><li>写优先锁<br>在有线程持有读锁的情况下，当其他线程想获取写锁时，会优先等待现有的读锁释放并获取写锁，并阻塞后来的读锁请求, 直到写锁释放。<blockquote><p>当一直有线程获取写锁，就会导致读线程饥饿</p></blockquote></li><li>公平读写锁<br>用队列把获取锁的线程排队，按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现饥饿的现象。</li></ul><h3 id="3-乐观锁"><a href="#3-乐观锁" class="headerlink" title="3. 乐观锁"></a>3. 乐观锁</h3><p>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。<br>乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以只有在<strong>冲突概率非常低</strong>，且<strong>加锁成本非常高</strong>的场景时，才考虑使用乐观锁。</p><h3 id="4-分布式锁-多个服务竞争同个资源"><a href="#4-分布式锁-多个服务竞争同个资源" class="headerlink" title="4. 分布式锁(多个服务竞争同个资源)"></a>4. 分布式锁(多个服务竞争同个资源)</h3><ul><li><p>setnx or (set )</p><ol><li>加锁</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用setnx</span><br>setnx lock_name uid<br>expire lock_name ttl<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用<span class="hljs-built_in">set</span> + nx</span><br>set lock_name uid ex ttl nx<br></code></pre></td></tr></table></figure><blockquote><p>ttl 生命周期(毫秒)</p></blockquote><p>使用<code>setnx</code>进行了两步操作，非原子操作，可能会出现死锁的情况，所以建议使用<code>set</code> + <code>nx</code>。</p><ol start="2"><li>解锁</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;get&quot;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span><br>  <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;del&quot;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>解锁时为避免非本人解锁，一般将服务的 uid (unique id) 存储在锁的 value 中，解锁是对比 value,防止错误解锁引发事故。<br>为保证原子性，所以使用 lua 脚本进行操作。</p></li><li><p>通过 sql 中的 unique 索引</p><ol><li>向表中的唯一索引列插入 lock_name，成功则获得锁成功，反之失败</li><li>通过 delete 语句删除 lock_name</li></ol></li><li><p>redisson 等等</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Locker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go内存对齐的一些问题</title>
    <link href="/20230418/golang-memory-align-use64in32/"/>
    <url>/20230418/golang-memory-align-use64in32/</url>
    
    <content type="html"><![CDATA[<h3 id="1-atomic-AddInt64在-32-位操作系统上内存对齐的问题"><a href="#1-atomic-AddInt64在-32-位操作系统上内存对齐的问题" class="headerlink" title="1. atomic.AddInt64在 32 位操作系统上内存对齐的问题"></a>1. <code>atomic.AddInt64</code>在 32 位操作系统上内存对齐的问题</h3><h4 id="1-1-问题"><a href="#1-1-问题" class="headerlink" title="1.1 问题"></a>1.1 问题</h4><p>在32位机器上使用int64可能会出现<code>panic: unaligned 64-bit atomic operation</code></p><h4 id="1-2-触发代码"><a href="#1-2-触发代码" class="headerlink" title="1.2 触发代码"></a>1.2 触发代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync/atomic&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Foo <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">int64</span><br>b <span class="hljs-type">int32</span><br>c <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> f Foo<br>atomic.AddInt64(&amp;f.a, <span class="hljs-number">1</span>) <span class="hljs-comment">// 这里不会崩溃</span><br>atomic.AddInt64(&amp;f.c, <span class="hljs-number">1</span>) <span class="hljs-comment">// 这里会崩溃</span><br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><h4 id="2-溯源"><a href="#2-溯源" class="headerlink" title="2. 溯源"></a>2. 溯源</h4><p>先看源码。源码是汇编写的，在<code>runtime/internal/atomic/atomic_&lt;系统架构&gt;.s</code>文件中，我这边使用的是 arm 架构，所以源码也是<code>atomic_arm.s</code>中的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs unix-assembly">TEXT ·Xadd64(SB),NOSPLIT,$-4-20<br>NO_LOCAL_POINTERS<br>MOVWaddr+0(FP), R1<br>CHECK_ALIGN<br><br>MOVBruntime·goarm(SB), R11<br>CMP$7, R11<br>BLT2(PC)<br>JMParmXadd64&lt;&gt;(SB)<br>JMP·goXadd64(SB)<br><br>TEXT armXadd64&lt;&gt;(SB),NOSPLIT,$0-20<br>// addr is already in R1<br>MOVWdelta_lo+4(FP), R2<br>MOVWdelta_hi+8(FP), R3<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go:nosplit</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goXadd64</span><span class="hljs-params">(addr *<span class="hljs-type">uint64</span>, delta <span class="hljs-type">int64</span>)</span></span> <span class="hljs-type">uint64</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-type">uintptr</span>(unsafe.Pointer(addr))&amp;<span class="hljs-number">7</span> != <span class="hljs-number">0</span> &#123;<br>*(*<span class="hljs-type">int</span>)(<span class="hljs-literal">nil</span>) = <span class="hljs-number">0</span> <span class="hljs-comment">// crash on unaligned uint64</span><br>&#125;<br>_ = *addr <span class="hljs-comment">// if nil, fault before taking the lock</span><br><span class="hljs-keyword">var</span> r <span class="hljs-type">uint64</span><br>addrLock(addr).lock()<br>r = *addr + <span class="hljs-type">uint64</span>(delta)<br>*addr = r<br>addrLock(addr).unlock()<br><span class="hljs-keyword">return</span> r<br>&#125;<br></code></pre></td></tr></table></figure><p>什么？汇编看不懂吗？其实我也看不懂…,问问 gpt 吧<br><img src="/images/2023-04-18_09-48-06.jpg"></p><p>汇编在调用时做了<code>CHECK_ALIGN</code>(内存对齐的检查)<br><img src="/images/2023-04-18_10-55-37.jpg"></p><p>在内存未对齐时，会直接产生 panic 进而中断程序，包括在<code>goXadd64</code>中也进行了判断<code>*(*int)(nil) = 0 // crash on unaligned uint64</code></p><p>参考：<a href="https://pengrl.com/p/21030/">yoko blog | 32位系统下，Go标准库中atomic原子操作int64有崩溃bug</a></p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Memory Align</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Etcd</title>
    <link href="/20230416/etcd-intro-md/"/>
    <url>/20230416/etcd-intro-md/</url>
    
    <content type="html"><![CDATA[<h3 id="1-etcd-是什么"><a href="#1-etcd-是什么" class="headerlink" title="1. etcd 是什么"></a>1. etcd 是什么</h3><p>etcd 是一个分布式键值对存储，设计用来可靠而快速的保存关键数据并提供访问。<br>通过分布式锁，leader 选举和写屏障(write barriers)来实现可靠的分布式协作。<br>etcd 集群是为高可用，持久性数据存储和检索而准备。</p><h4 id="1-1-etcd-的应用场景"><a href="#1-1-etcd-的应用场景" class="headerlink" title="1.1 etcd 的应用场景:"></a>1.1 etcd 的应用场景:</h4><ul><li>服务发现</li><li>消息发布和订阅</li><li>负载均衡</li><li>分布式锁、分布式队列</li><li>集群监控和 leader 竞选</li></ul><h3 id="2-etcd-的基本操作"><a href="#2-etcd-的基本操作" class="headerlink" title="2. etcd 的基本操作"></a>2. etcd 的基本操作</h3><ul><li>通过 http 进行通信</li><li>通过 etcdctl 连接进行操作</li></ul><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">put指令(update or create <span class="hljs-keyword">if</span> key not exist)</span><br>etcdctl put [key] [value]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">------</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">get指令(search key-value)</span><br>etcdctl get [key]<br>etcdctl get [key1] [key2] [key3] […]<br>etcdctl get [ke] --prefix<br>etcdctl get [key] -w json # 使用json格式输出<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">------</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">del指令(delete key-value)</span><br>etcdctl del [key1] […]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">------</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">watch指令(Monitor the operation of the target key)</span><br>etcdctl watch [key]             # 监控单个key<br>etcdctl watch [key] --prefix    # 监控一类前缀的key<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">------</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">txn指令(事务)</span><br>etcdctl txn -i<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">------</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">lease指令(租约，即key的TTL生存时间)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">etcd需要先创建租约才能通过`etcdctl put --lease=&lt;lease_id&gt; [key] [value]`来设置key-value的TTL</span><br><br>etcdctl lease grant 30          # 创建一个TTL=30s的租约<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">lease &lt;lease_id&gt; granted with TTL(30s)</span><br>etcdctl put --lease=&lt;lease_id&gt; [key] [value]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">lease也会随着TTL时间过去而到期</span><br></code></pre></td></tr></table></figure><h3 id="3-etcd-的集群一致性"><a href="#3-etcd-的集群一致性" class="headerlink" title="3. etcd 的集群一致性"></a>3. etcd 的集群一致性</h3><p>etcd 使用 Raft 协议，实现强一致性</p><h4 id="3-1-Raft-协议架构"><a href="#3-1-Raft-协议架构" class="headerlink" title="3.1 Raft 协议架构"></a>3.1 Raft 协议架构</h4><p>raft 协议中，节点有三种角色：leader、follower、candidate。<br>初始，所有节点都为 follower，当 follower 节点在指定时常内没收到 leader 的心跳包，就会晋升为 candidate(候选节点)，<br>候选节点会向其他节点发送投票请求，请求其他节点投票，票数超过集群节点数量一半的节点会晋升为 leader。leader 负责处理所有客户端的事务请求。<br>若事务请求没到 leader，follower 节点也会将请求转发给 leader。</p><h4 id="3-2-Raft-协议一致性"><a href="#3-2-Raft-协议一致性" class="headerlink" title="3.2 Raft 协议一致性"></a>3.2 Raft 协议一致性</h4><p>当 leader 节点接收到事务请求后，会先写入本地日志，然后向集群中每个 follower 节点发送请求，询问是否可以更新数据。<br>若超过一半节点都认同此次操作，则 leader 节点会将数据更新，将结果返回给客户端，并通知每个 follower 节点，更新自己的数据。从而保证集群数据的一致性</p>]]></content>
    
    
    <categories>
      
      <category>NoSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Etcd</tag>
      
      <tag>Service Discovery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/20230416/redis-intro-md/"/>
    <url>/20230416/redis-intro-md/</url>
    
    <content type="html"><![CDATA[<h3 id="1-redis-简介"><a href="#1-redis-简介" class="headerlink" title="1. redis 简介"></a>1. redis 简介</h3><p>redis 是内存型 NoSQL 数据库，因其使用内存存储，性能优越，其读写速度远超其他类型的数据库。</p><h4 id="1-1-redis-的应用场景"><a href="#1-1-redis-的应用场景" class="headerlink" title="1.1 redis 的应用场景"></a>1.1 redis 的应用场景</h4><ul><li>缓存：使用 redis 存储一些常用的主要数据可以提升响应速度（redis 和数据库的数据一致性）</li><li>高速读写场合：在高频次读写操作时，数据库的响应就会显著降低。而这时，使用 redis 进行高速读写，在读写结束时，异步将数据写入数据库中</li></ul><h3 id="2-redis-的数据类型和基本操作"><a href="#2-redis-的数据类型和基本操作" class="headerlink" title="2.redis 的数据类型和基本操作"></a>2.redis 的数据类型和基本操作</h3><h4 id="2-1-redis-的数据类型"><a href="#2-1-redis-的数据类型" class="headerlink" title="2.1 redis 的数据类型"></a>2.1 redis 的数据类型</h4><ul><li>String(二进制安全，可以存储任何数据，例如 jpg 或其他序列化字节，最大存储 512MB)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">update or (create <span class="hljs-keyword">if</span> not exist)</span><br>set [key] [value]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">search key</span><br>get [key]<br></code></pre></td></tr></table></figure><ul><li>Hash</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">update or (create <span class="hljs-keyword">if</span> not exist) field</span><br>hset [key] [field1] [value1] […] […]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">search field of hset key</span><br>hget [key] [field1]<br></code></pre></td></tr></table></figure><span id="more"></span><ul><li>List(按照插入顺序排序)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">队列</span><br>lpush [key] [value1]<br>lpush [key] [value2]<br><br>rpop [key]<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">value1</span><br>rpop [key]<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">value2</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">-------</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">栈</span><br>lpush [key] [value1]<br>lpush [key] [value2]<br><br>lpop [key]<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">value2</span><br>lpop [key]<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">value1</span><br><br></code></pre></td></tr></table></figure><ul><li>Set(String 的无序集合)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">add</span><br>sadd [key] [member1]<br>sadd [key] [member2]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看<span class="hljs-built_in">set</span>中所有元素</span><br>smembers [key]<br><br></code></pre></td></tr></table></figure><ul><li>Zset(有序集合，通过关联分数从而有序)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">zadd [key] [score] [member1]<br>zadd [key] [score] [member2]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看zset中分为在[minScore, maxScore]中的元素</span><br>zrangebyscore [key] [minScore] [maxScore]<br></code></pre></td></tr></table></figure><h4 id="2-2-发布订阅-消息通信模式"><a href="#2-2-发布订阅-消息通信模式" class="headerlink" title="2.2 发布订阅(消息通信模式)"></a>2.2 发布订阅(消息通信模式)</h4><ol><li>一个或多个客户端通过<code>subscribe [channel_key]</code>订阅频道</li><li>服务端通过<code>publish [channel_key] [msg]</code>发布消息，每个订阅的客户端都会受到消息</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">client1</span><br>subscribe msg_channel<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">client2</span><br>subscribe msg_channel<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">server</span><br>publish msg_channel &quot;hello world&quot;<br><br></code></pre></td></tr></table></figure><h4 id="2-3-事务"><a href="#2-3-事务" class="headerlink" title="2.3 事务"></a>2.3 事务</h4><p>和数据库业务不同，redis 事务非原子性，且事务中某个操作失败，不会回滚，也不会停止事务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开启事务</span><br>multi<br><br>[cmd …]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">监视keys, 在事务执行前，有被监视的key被改动，则事务将会被打断(`unwatch [key] […]`取消监视)</span><br>watch [key] […]<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行事务</span><br>exec<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">取消事务</span><br>discard<br></code></pre></td></tr></table></figure><h4 id="2-4-数据备份和恢复"><a href="#2-4-数据备份和恢复" class="headerlink" title="2.4 数据备份和恢复"></a>2.4 数据备份和恢复</h4><p>……</p><h4 id="2-5-Redis-管道"><a href="#2-5-Redis-管道" class="headerlink" title="2.5 Redis 管道"></a>2.5 Redis 管道</h4><p>……</p><h3 id="3-Reids-淘汰策略"><a href="#3-Reids-淘汰策略" class="headerlink" title="3. Reids 淘汰策略"></a>3. Reids 淘汰策略</h3><p>当内存超出物理内存限制，就会使用 swap 或虚拟内存，这都是和磁盘进行交换，会导致 redis 的性能大打折扣。<br>所以生产环境中，都会设置<code>maxmemory</code>参数限制 redis 最大占用。当 redis 内存占用超过<code>maxmemory</code>后，新的数据无法写入，<br>redis 提供了几种淘汰策略，清理数据用于存放新的数据。</p><ul><li>noeviction(default): 不可写入新的数据，也不会丢弃数据</li><li>volatile-lru: 淘汰具有过期时间且最近最少使用的 key</li><li>allkeys-lru: 淘汰最近最少使用的 key</li><li>volatile-ttl: 淘汰具有过期时间且 ttl 最小的 key</li><li>volatile-random: 随机淘汰具有过期时间的 key</li><li>allkeys-random: 随机淘汰 key</li></ul><h4 id="3-1-近似-LRU-算法"><a href="#3-1-近似-LRU-算法" class="headerlink" title="3.1 近似 LRU 算法"></a>3.1 近似 LRU 算法</h4><p>Redis 使用近似 LRU 算法，因为 LRU 算法还需要一个链表按照访问时间顺序保存节点，这将占用大量的额外内存，<br>近似 LRU 算法是 Redis 在现有的数据结构基础上使用随机采样法来淘汰元素，可以达到与 LRU 算法非常近似的效果，Redis 给每个 key 增加了一个额外的小字段，长度为 24 个 bit，用于保存最后一次访问的时间戳。</p><h4 id="3-2-随机采样"><a href="#3-2-随机采样" class="headerlink" title="3.2 随机采样"></a>3.2 随机采样</h4><p>近似 LRU 算法触发是在 Redis 执行写操作时，发现内存超出 maxmemory 的值了，就会执行一次该算法，通过随机采样出 maxmemory_samples (默认值为 5) 个 key，然后淘汰掉最旧的一个 key，如果淘汰后内存还是超出 maxmemory，那就继续随机采样淘汰，直到低于 maxmemory。<br>采样的数据根据 maxmemory-policy 的设置决定，如果是 allkeys，在所有的字典 key 中进行采样，如果是 volatile，则在具有过期时间 key 的字典中采样，采样的数量根据 maxmemory_samples 配置得来，采样数量越大，近似 LRU 算法的效果越接近严格 LRU 算法，<br>同时在 Redis3.0 中，还增加了一个淘汰池数组，大小是 maxmemory_samples，在每一次淘汰循环中，新的采样出来的 key 会和淘汰池中的 key 进行融合，淘汰掉最旧的一个 key，然后将剩余最旧的 key 列表放入淘汰池，等待下次循环。</p><h3 id="4-Redis-集群"><a href="#4-Redis-集群" class="headerlink" title="4. Redis 集群"></a>4. Redis 集群</h3><ul><li><p>主从复制</p></li><li><p>sentinel 模式(哨兵)</p></li><li><p>cluster 模式</p></li></ul><h3 id="5-Redis-特殊数据结构的底层实现"><a href="#5-Redis-特殊数据结构的底层实现" class="headerlink" title="5. Redis 特殊数据结构的底层实现"></a>5. Redis 特殊数据结构的底层实现</h3><h4 id="5-1-Set"><a href="#5-1-Set" class="headerlink" title="5.1 Set"></a>5.1 Set</h4><ul><li><p>intset</p></li><li><p>hashtable<br>使用 hash 中 key 的唯一性来确定 set 中值不会重复</p></li></ul><h4 id="5-2-ZSet"><a href="#5-2-ZSet" class="headerlink" title="5.2 ZSet"></a>5.2 ZSet</h4><blockquote><p>当满足以下两个条件使用 ziplist，反之则使用 skiplist</p><ul><li>zset 元素数量少于 128</li><li>zset 的所有元素字长都&lt;&#x3D; 64 字节</li></ul></blockquote><ul><li><p>ziplist</p></li><li><p>skiplist</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>NoSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>KeyValueDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go的cpu调度</title>
    <link href="/20230410/golang-cpu-schedula/"/>
    <url>/20230410/golang-cpu-schedula/</url>
    
    <content type="html"><![CDATA[<h3 id="1-调度模型-GPM"><a href="#1-调度模型-GPM" class="headerlink" title="1. 调度模型 GPM"></a>1. 调度模型 GPM</h3>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go面试问题</title>
    <link href="/20230410/golang-interview/"/>
    <url>/20230410/golang-interview/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Slice-扩容机制"><a href="#1-Slice-扩容机制" class="headerlink" title="1. Slice 扩容机制"></a>1. Slice 扩容机制</h3><ul><li><p>当 newLen &gt;&#x3D; 2 * cap, 则 newCap &#x3D; newLen</p></li><li><p>当 newLen &lt; 2 * cap</p><ul><li>如果 cap &lt; 256, 则 newCap &#x3D; 2 * cap</li><li>如果 cap &gt;&#x3D; 256, 则 newCap &#x3D; cap + (cap + 3 * threshold) &#x2F; 4, 即 1.25 倍容量+ 0.75 倍阈值的平滑因子, 平滑因子在各个阈值阶段也会不同<table><thead><tr><th align="center">starting cap</th><th align="center">growth factor</th></tr></thead><tbody><tr><td align="center">256</td><td align="center">2.0</td></tr><tr><td align="center">512</td><td align="center">1.63</td></tr><tr><td align="center">1024</td><td align="center">1.44</td></tr><tr><td align="center">2048</td><td align="center">1.35</td></tr><tr><td align="center">4096</td><td align="center">1.30</td></tr></tbody></table></li></ul></li></ul><span id="more"></span><h3 id="2-结构体所占字节长度怎么计算"><a href="#2-结构体所占字节长度怎么计算" class="headerlink" title="2. 结构体所占字节长度怎么计算"></a>2. 结构体所占字节长度怎么计算</h3><p>可以使用<code>unsafe</code>包中的<code>Sizeof</code>函数来计算结构体所占字节长度</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-comment">// 结构体内存对齐长度是按结构体中最长字段对齐，如下为int64 - 8字节</span><br><span class="hljs-comment">// |up| |down|down|score|score|score|score|id|id|id|id|id|id|id|id|</span><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Up    <span class="hljs-type">int8</span><br>Down  <span class="hljs-type">int16</span><br>Score <span class="hljs-type">int32</span><br>Id    <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := Student&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">98</span>, <span class="hljs-number">123456</span>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;unsafe.Sizeof(s): %v\n&quot;</span>, unsafe.Sizeof(s))<br>&#125;<br></code></pre></td></tr></table></figure><p>output</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">unsafe</span>.Sizeof(s): <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL优化策略</title>
    <link href="/20230410/sql-optimization-strategy/"/>
    <url>/20230410/sql-optimization-strategy/</url>
    
    <content type="html"><![CDATA[<h3 id="1-MYSQL-优化的几个原则"><a href="#1-MYSQL-优化的几个原则" class="headerlink" title="1. MYSQL 优化的几个原则"></a>1. MYSQL 优化的几个原则</h3><ul><li>减少数据访问：设置合理的字段类型，启用压缩，通过索引访问等减少磁盘 IO</li><li>返回更少的数据：只返回需要的字段和数据分页处理，减少磁盘和网络 IO</li><li>减少交互次数：批量 DML 操作，函数存储等减少数据连接次数</li><li>利用更多资源：使用表分区，并增加并行操作，更大限度利用 CPU 资源</li></ul><p>总结一下</p><ul><li>最大化利用索引</li><li>尽可能避免全表扫描</li><li>减少无效数据的查询</li></ul><h3 id="2-优化策略"><a href="#2-优化策略" class="headerlink" title="2. 优化策略"></a>2. 优化策略</h3><blockquote><p>声明：以下 SQL 优化策略适用于数据量较大的场景下，如果数据量较小，没必要以此为准，以免画蛇添足。</p></blockquote><h4 id="2-1-避免不走索引的场景"><a href="#2-1-避免不走索引的场景" class="headerlink" title="2.1 避免不走索引的场景"></a>2.1 避免不走索引的场景</h4><ol><li>尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引，进行全表扫描</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># bad<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> username <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%王%&#x27;</span><br># good<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> username <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;王%&#x27;</span><br></code></pre></td></tr></table></figure><p>如果需要在前面使用模糊查询，提供几个解决思路：</p><ul><li>使用 MySQL 内置函数<code>INSTR(str, substr)</code>来匹配</li><li>使用 FullText 全文索引，用 match against 检索</li><li>数据量较大的情况，建议引入 ElasticSearch、solr，亿级数据量检索速度秒级</li><li>当表数据量较少（几千条左右），直接<code>like &#39;%xx%&#39;</code></li></ul><span id="more"></span><ol start="2"><li>尽量避免使用<code>in</code> 和<code>not in</code>，当 in 的取值范围过大时，会导致索引失效，引擎走全表扫描</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># bad<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>);<br></code></pre></td></tr></table></figure><ul><li>如果是连续数据，可用<code>between</code>代替</li><li>如果是子查询，可以用<code>exists</code>代替</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">Between</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> <span class="hljs-number">9</span>;<br><br># bad<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> t2)<br># good<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> t2 <span class="hljs-keyword">WHERE</span> t1.id <span class="hljs-operator">=</span> t2.id)<br>#<br></code></pre></td></tr></table></figure><ol start="3"><li><p>尽量避免使用 or 连接<strong>未使用索引的条件</strong>，或像 IN 这种<strong>过滤范围不大</strong>的条件，会导致引擎走全表扫描</p></li><li><p>尽量避免使用 NULL 值判断，NULL 判断会导致引擎走全表扫描</p></li><li><p>尽量避免在条件<strong>等式的左侧</strong>进行<strong>表示式</strong>或<strong>函数</strong>操作，会导致引擎走全表扫描</p></li><li><p>尽量避免使用<code>&lt;&gt;</code>或<code>!=</code>，会导致引擎走全表扫描。</p></li><li><p>使用联合索引检索时，MySQl 联合索引<strong>最左匹配原则</strong>, 即 ABC 索引，条件为 AC 或 BC 都无法使用索引，但 A,AB 可以</p></li><li><p>隐式类型转换造成不使用索引</p></li><li><p>order by 的字段如果没有索引的话，将会进行全表扫描</p></li></ol><h4 id="2-2-SELECT-的其他优化"><a href="#2-2-SELECT-的其他优化" class="headerlink" title="2.2 SELECT 的其他优化"></a>2.2 SELECT 的其他优化</h4>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>Postgres</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go内存管理</title>
    <link href="/20230410/golang-memory-management/"/>
    <url>/20230410/golang-memory-management/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://zhuanlan.zhihu.com/p/76802887">详解 Go 语言的内存模型及堆的分配管理</a> ,建议 tm 反复观看</p></blockquote><p>golang 的内存管理是借鉴了 TCMalloc(Thread Cache Malloc)，随着 Go 的迭代，Go 的内存管理与 TCMalloc 不一致的地方也在扩大，但其主要思想是一致的。只是比 TCMalloc 多了<strong>逃逸分析</strong>和<strong>垃圾回收</strong>。</p><h4 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h4><p><img src="https://pic4.zhimg.com/80/v2-1aa731ddd77b6cad73c8f68f864ea5ef_720w.webp" alt="架构"></p><ul><li>page: 图中的浅蓝方块,在 x86 架构中一个 page 大小为 8KB</li><li>span: 内存管理的基本单位，由一组连续的 page 组成,图中的浅蓝长方形和紫色方块</li><li>mcache: mcache 保存的是各种大小的 Span，并按 Span class 分类，小对象直接从 mcache 分配内存，它起到了缓存的作用，并且可以无锁访问。Go 中是每个 P 拥有 1 个 mcache。在 Go 程序中，当前最多有 GOMAXPROCS 个线程在运行，所以最多需要 GOMAXPROCS 个 mcache 就可以保证各线程对 mcache 的无锁访问，线程的运行又是与 P 绑定的，把 mcache 交给 P 刚刚好。</li><li>mcentral: 所有线程共享的缓存，需要加锁访问。按 Span class 对 Span 分类，然后串联成链表，当 mcache 的某个 class 的 Span 的内存被分配光时，它会向 mcentral 申请 1 个当前级别的 Span。</li><li>mheap: 堆内存的抽象，把从 OS 申请出的内存页组织成 Span，并保存起来。当 mcentral 的 Span 不够用时会向 mheap 申请内存，而 mheap 的 Span 不够用时会向 OS 申请内存。mheap 向 OS 的内存申请是按页来的，然后把申请来的内存页生成 Span 组织起来，同样也是需要加锁访问的。mheap 把 Span 组织成了树结构，共 2 棵树，然后把 Span 分配到 heapArena 进行管理，它包含地址映射和 span 是否包含指针等位图，这样做的主要原因是为了更高效的利用内存：分配、回收和再利用。</li></ul><h4 id="大小对象"><a href="#大小对象" class="headerlink" title="大小对象"></a>大小对象</h4><p><img src="https://pic4.zhimg.com/80/v2-14196cbb8fc199f5257fd94617210557_720w.webp" alt="对象分类"></p><ul><li>小对象(&lt;&#x3D; 32KB)直接在 mcache 中分配</li><li>大对象(&gt; 32KB)直接从 mheap 中分配</li></ul><span id="more"></span><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><blockquote><p>原文见：<a href="https://zhuanlan.zhihu.com/p/91559562">golang 逃逸分析详解</a> ,建议 tmd 反复观看</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">go run -gcflags &quot;-m -l&quot; main.go<br><span class="hljs-meta prompt_"># </span><span class="language-bash">      -m    打印逃逸分析信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">      -l    禁止内联编译)</span><br></code></pre></td></tr></table></figure><p>逃逸规则如下：</p><ol><li>在某个函数内部<strong>new 生成的指针</strong>或者<strong>字面量的指针</strong>被当成函数返回值，则该变量一定发生了逃逸(构造函数返回的指针一定逃逸)</li><li>被 slice、map、chan 引用的<strong>指针</strong>一定发生了逃逸<blockquote><p>stack overflow 上有人提问为什么使用指针的 chan 比使用值的 chan 慢 30%，答案就在这里：使用指针的 chan 发生逃逸，gc 拖慢了速度。<a href="https://link.zhihu.com/?target=https://stackoverflow.com/questions/41178729/why-passing-pointers-to-channel-is-slower">Why passing pointers to channel is slower</a></p></blockquote></li><li>被<strong>已经逃逸的变量引用的指针</strong>一定发生了逃逸</li></ol>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层</title>
    <link href="/20230408/transport-layout/"/>
    <url>/20230408/transport-layout/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Transport Layout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UDP</title>
    <link href="/20230408/udp-intro/"/>
    <url>/20230408/udp-intro/</url>
    
    <content type="html"><![CDATA[<blockquote><p>UDP 协议仅仅在提供了复用&#x2F;分解功能和少量的差错检验</p></blockquote><h3 id="1-UDP-报文结构"><a href="#1-UDP-报文结构" class="headerlink" title="1. UDP 报文结构"></a>1. UDP 报文结构</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 代码示例，真正报文结构为二进制</span><br><span class="hljs-keyword">type</span> <span class="hljs-keyword">struct</span> udp &#123;<br>    <span class="hljs-comment">// header</span><br>    source_port <span class="hljs-type">int16</span> <span class="hljs-comment">//源端端口</span><br>    target_port <span class="hljs-type">int16</span> <span class="hljs-comment">//目的端口</span><br>    length      <span class="hljs-type">int16</span> <span class="hljs-comment">//长度</span><br>    checksum    <span class="hljs-type">int16</span> <span class="hljs-comment">//检验和</span><br>    <span class="hljs-comment">// body</span><br>    data        []<span class="hljs-type">byte</span><br>&#125;<br></code></pre></td></tr></table></figure><p>头部共四个字段，每个字段由两个字节组成，共计 8 个字节</p><h3 id="2-UDP-检验和"><a href="#2-UDP-检验和" class="headerlink" title="2. UDP 检验和"></a>2. UDP 检验和</h3><p>计算检验和时，加入伪头部</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> <span class="hljs-keyword">struct</span> udp_virtual_header &#123;<br>    source_ip  <span class="hljs-type">int32</span><br>    target_ip  <span class="hljs-type">int32</span><br>    _          <span class="hljs-type">int8</span><br>    udp_type   <span class="hljs-type">int8</span><br>    udp_length <span class="hljs-type">int16</span><br>&#125;<br></code></pre></td></tr></table></figure><p>将伪头部和报文中所有 16bit 字(2Byte)相加，data 最后不足 16bit 补零。溢出位回卷(回卷：溢出位和 16bit 相加)，然后进行反码运算。<br>在校验时，将伪头部和报文中所有 16bit 字相加，和为 1111111111111111 则校验成功，反之失败,说明报文受损。</p><h3 id="3-UDP-相对于-TCP-的优势"><a href="#3-UDP-相对于-TCP-的优势" class="headerlink" title="3. UDP 相对于 TCP 的优势"></a>3. UDP 相对于 TCP 的优势</h3><ul><li>没有拥塞控制，更适合及时性质的传输</li><li>无需建立连接，相比于 TCP 有更低的时延</li><li>无状态连接，无需像 TCP 一般维护连接的参数（例如：接受和发送缓存、拥塞控制参数、序号和确认号等）</li><li>首部开销更小，UDP 头部 8Byte, TCP 首部 20Byte</li></ul>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UDP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http简介</title>
    <link href="/20230406/http-intro/"/>
    <url>/20230406/http-intro/</url>
    
    <content type="html"><![CDATA[<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><h3 id="2-HTTP-报文"><a href="#2-HTTP-报文" class="headerlink" title="2. HTTP 报文"></a>2. HTTP 报文</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dot"><br></code></pre></td></tr></table></figure><h3 id="3-持续连接和非持续连接"><a href="#3-持续连接和非持续连接" class="headerlink" title="3. 持续连接和非持续连接"></a>3. 持续连接和非持续连接</h3><ul><li><p>HTTP&#x2F;1.0 默认使用非持续连接，如要使用持续连接，在报文头部添加<code>Connection: keep-alive</code></p></li><li><p>HTTP&#x2F;1.1 默认使用持续连接，如要使用非持续连接，在报文头部添加<code>Connection: close</code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Debug</title>
    <link href="/20221103/golang-debug/"/>
    <url>/20221103/golang-debug/</url>
    
    <content type="html"><![CDATA[<h3 id="1-pprof"><a href="#1-pprof" class="headerlink" title="1. pprof"></a>1. pprof</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-comment">// import pprof to init</span><br>_ <span class="hljs-string">&quot;net/http/pprof&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-1-web"><a href="#1-1-web" class="headerlink" title="1.1 web"></a>1.1 web</h4><p>http 访问<code>http://localhost:8080/debug/pprof</code>可以查看到如下内容<br><img src="https://i.imgur.com/KUmRUa9.png" alt="pprof"></p><ul><li>内存分配</li><li>goroutine数量</li><li>堆分配</li><li>资源竞争</li><li>线程创建</li><li>等</li></ul><h4 id="1-2-go-tool"><a href="#1-2-go-tool" class="headerlink" title="1.2 go tool"></a>1.2 <code>go tool</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go tool pprof -http=:8000 http://127.0.0.1:8080/debug/pprof/profile</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go tool pprof -http=:8000 cpu.out</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go tool pprof -http=:8000 pprof.XXX.samples.cpu.001.pb.gz</span><br></code></pre></td></tr></table></figure><p>开启另一个web服务分析获取的信息，浏览器打开<code>http://localhost:8000</code>即可查看到如下页面<br><img src="https://i.imgur.com/z1SKdPS.png" alt="pprof"><br>并包含有火焰图</p>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang笺言</title>
    <link href="/20220806/golang-proverbs/"/>
    <url>/20220806/golang-proverbs/</url>
    
    <content type="html"><![CDATA[<!-- 刚毕业的我就被公司以某些理由炒了，所以我来继续学习了<span class="github-emoji" alias="sob" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">&#x1f62d;</span> --><p>本篇文章是学习<a href="https://github.com/cristaloleg/go-advice">go-advice</a>时所写，包含了大部分写 go 需要注意的点</p><h3 id="1-谏言"><a href="#1-谏言" class="headerlink" title="1. 谏言"></a>1. 谏言</h3><ul><li>不要通过共享内存进行通信，通过通信共享内存</li><li>并发不是并行 <span class="github-emoji" alias="heavy_check_mark" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">&#x2714;</span></li><li>管道用于协调；互斥量（锁）用于同步 <span class="github-emoji" alias="heavy_check_mark" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">&#x2714;</span></li><li>接口越大，抽象越弱 <span class="github-emoji" alias="heavy_check_mark" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">&#x2714;</span></li><li>利用好零值</li><li>空结构<code>interface&#123;&#125;</code>即<code>any</code>没有任何类型约束 <span class="github-emoji" alias="heavy_check_mark" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">&#x2714;</span></li><li>gofmt 的风格不是人们最喜欢的，但 gofmt 是每个人的最爱</li><li>一点点重复比引入一点点依赖更好</li><li>始终使用构建标记保护系统调用和 cgo</li><li>cgo 不是 go</li><li>使用<code>unsafe</code>不能保证能如期运行</li><li>清晰比聪明更好</li><li>反射永远不清晰</li><li>错误是值</li><li>不要只检查错误，还要优雅的处理它们</li><li>设计架构，命名组件，文档记录细节</li><li>文档是供用户使用的</li><li>不要（在生产环境）使用<code>panic()</code></li></ul><span id="more"></span><h3 id="2-目标"><a href="#2-目标" class="headerlink" title="2. 目标"></a>2. 目标</h3><ul><li>每个 package 实现单一的目的</li><li>显示处理错误</li><li>尽早返回，而不是使用深嵌套</li><li>让调用者处理并发（带来的问题）</li><li>在启动一个 goroutine 时，需要知道它何时会停止</li><li>避免 package 级别的状态</li><li>简单很重要</li><li>编写测试以锁定 package API 的行为</li><li>如果你觉得很慢，先编写 benchmark 来证明</li><li>适度是一种美德</li><li>可维护性</li></ul><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h3><ul><li><p>使用<code>go fmt</code>格式化</p><blockquote><p>让团队一起使用官方的 Go 格式化工具，不要重新发明轮子，尝试减少代码复杂度，使代码更易于阅读</p></blockquote></li><li><p>多个 if 语句折叠成 switch</p></li><li><p>使用<code>chan struct&#123;&#125;</code>来传递信号，<code>chan bool</code>表达不够清楚</p></li><li><p><code>30 * time.Second</code>比<code>time.Duration(30) * time.Second</code>更好</p></li><li><p>用<code>time.Duration</code>替代<code>int64</code>+变量名</p></li><li><p>按类型分组<code>const</code>声明，按逻辑或类型分组<code>var</code></p></li><li><p>每个<strong>阻塞</strong>或者<strong>IO 函数</strong>操作应该是可取消或者至少是可超时的</p></li><li><p>为整型常量值实现<code>Stringer</code><a href="https://godoc.org/golang.org/x/tools/cmd/stringer"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a>接口</p></li><li><p>检查<code>defer</code>中的错误</p></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>    err := body.Clost()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>不要在<code>checkErr</code>函数中使用<code>panic()</code>或<code>os.Exit()</code></li><li>仅仅在很特殊的情况下才使用<code>panic()</code>，你必须要去处理<code>error</code></li><li>不要给枚举使用别名，因为这样打破了类型安全<a href="https://play.golang.org/p/MGbeDwtXN3"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">type</span> Status = <span class="hljs-type">int</span><br><span class="hljs-keyword">type</span> Format = <span class="hljs-type">int</span> <span class="hljs-comment">// remove `=` to have type safety</span><br><br><span class="hljs-keyword">const</span> A Status = <span class="hljs-number">1</span><br><span class="hljs-keyword">const</span> B Format = <span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-built_in">println</span>(A == B) <span class="hljs-comment">// true, but a.type != b.type</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果你想省略返回参数，你最好表示出来，<code>_ = f()</code>比<code>f()</code>更好</li><li>我们用<code>a := []T&#123;&#125;</code>简单初始化 slice</li><li>用 range 循环来进行数组或 slice 的迭代</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 更好</span><br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> a[<span class="hljs-number">3</span>:<span class="hljs-number">7</span>] &#123; ... &#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">3</span>; i &lt; <span class="hljs-number">7</span>; i++ &#123; ...&#125;<br><br></code></pre></td></tr></table></figure><ul><li>多行字符串用反引号</li><li>用<code>_</code>来跳过不用的参数</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(a <span class="hljs-type">int</span>, _ <span class="hljs-type">string</span>)</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>如果你要比较时间戳，请使用<code>time.Before()</code>或<code>time.After()</code>，不要使用<code>time.Sub()</code>来获得 duration，然后检查他的值</li><li>带有上下文的函数第一个参数名为<code>ctx</code>，形如<code>func foo(ctx Context, ...)</code></li><li>几个类型相同的参数定义可以用简短的方式来定义，<code>func f(a int, b, c string)</code></li><li>一个 slice 的零值是 nil<br><a href="https://play.golang.org/p/pNT0d_Bunq"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span><br>fmt.Println(s, <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">cap</span>(s))<br><span class="hljs-keyword">if</span> s == <span class="hljs-literal">nil</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;nil!&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// [] 0 0</span><br><span class="hljs-comment">// nil!</span><br></code></pre></td></tr></table></figure><p><a href="https://play.golang.org/p/meTInNyxtk"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> a []<span class="hljs-type">string</span><br>b := []<span class="hljs-type">string</span>&#123;&#125;<br><br>fmt.Println(reflect.DeepEqual(a, []<span class="hljs-type">string</span>&#123;&#125;))<br>fmt.Println(reflect.DeepEqual(b, []<span class="hljs-type">string</span>&#123;&#125;))<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// false</span><br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ul><li>不要将枚举类型与<code>&lt;</code>,<code>&gt;</code>,<code>&lt;=</code>,<code>&gt;=</code>进行比较，使用确定的值</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang">value := reflect.ValueOf(object)<br>kind := value.Kind()<br><span class="hljs-keyword">if</span> kind &gt;= reflect.Chan &amp;&amp; kind &lt;= reflect.Slice &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>用<code>%+v</code>来打印数据比较全的信息</li><li>注意空结构<code>struct&#123;&#125;</code>，看 issue: <a href="https://github.com/golang/go/issues/23440">golang&#x2F;go#23440</a> or <a href="https://play.golang.org/p/9C0puRUstrP"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a, b <span class="hljs-keyword">struct</span>&#123;&#125;<br>    <span class="hljs-built_in">print</span>(&amp;a, <span class="hljs-string">&quot;\n&quot;</span>, &amp;b, <span class="hljs-string">&quot;\n&quot;</span>) <span class="hljs-comment">// Prints same address</span><br>    fmt.Println(&amp;a == &amp;b)     <span class="hljs-comment">// Comparison returns false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a, b <span class="hljs-keyword">struct</span>&#123;&#125;<br>    fmt.Printf(<span class="hljs-string">&quot;%p\n%p\n&quot;</span>, &amp;a, &amp;b) <span class="hljs-comment">// Again, same address</span><br>    fmt.Println(&amp;a == &amp;b)          <span class="hljs-comment">// ...but the comparison returns true</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>包装错误<a href="http://github.com/pkg/errors"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a>，如<code>errors.Wrap(err, &quot;additional message to a given error&quot;)</code></li><li>在 go 里要小心使用<code>range</code><ol><li><code>for i := range a</code>和<code>for i,v := range &amp;a</code>，都不是<code>a</code>的副本</li><li><code>for i, v := range a</code>里面就是<code>a</code>的副本</li><li>more <a href="https://play.golang.org/p/4b181zkB1O"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li></ol></li><li>从 map 里读取一个不存在的 key 不会 panic</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang">value := <span class="hljs-keyword">map</span>[<span class="hljs-string">&quot;no_key&quot;</span>]  <span class="hljs-comment">// return 0</span><br><br><span class="hljs-comment">// well</span><br>value, ok := <span class="hljs-keyword">map</span>[<span class="hljs-string">&quot;no_key&quot;</span>] <span class="hljs-comment">// return 0, false and check ok</span><br></code></pre></td></tr></table></figure><ul><li>不要使用原始参数进行文件操作</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// bad</span><br>os.MkdirAll(path, <span class="hljs-number">0700</span>)<br><br><span class="hljs-comment">// good</span><br>os.MkdirAll(path, os.FileMode)<br></code></pre></td></tr></table></figure><ul><li>要不忘记对<code>iota</code>指定一种类型<a href="https://play.golang.org/p/mZZdMaI92cI"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">const</span> (<br>  _ = <span class="hljs-literal">iota</span><br>  testvar         <span class="hljs-comment">// testvar 将是 int 类型</span><br>)<br><br><span class="hljs-keyword">type</span> myType <span class="hljs-type">int</span><br><span class="hljs-keyword">const</span> (<br>  _ myType = <span class="hljs-literal">iota</span><br>  testvar         <span class="hljs-comment">// testvar 将是 myType 类型</span><br>)<br></code></pre></td></tr></table></figure><ul><li>不要在你不拥有的结构上使用<code>encoding/gob</code>，在某些时候，结构可能会改变，而你可能会错过这一点。因此，这可能会导致很难找到 bug。</li><li>不要依赖于计算顺序，特别是在<code>return</code>语句中</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// BAD</span><br><span class="hljs-keyword">return</span> res, json.Unmarshal(b, &amp;res)<br><br><span class="hljs-comment">// GOOD</span><br>err := json.Unmarshal(b, &amp;res)<br><span class="hljs-keyword">return</span> res, err<br></code></pre></td></tr></table></figure><ul><li>防止结构体字段用纯值方式初始化，添加<code>_ struct&#123;&#125;</code>字段</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>  X, Y <span class="hljs-type">float64</span><br>  _    <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// to prevent unkeyed literals</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    p1 := Point&#123;X: <span class="hljs-number">1</span>, Y: <span class="hljs-number">1</span>&#125;<br>    p2 := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;           <span class="hljs-comment">// compile error</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>防止结构比较，可以添加<code>func</code>类型的空字段</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>    _ [<span class="hljs-number">0</span>]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-comment">// unexported, zero-width non-comparable field</span><br>    X, Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    p1, p2 := Point(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), Point(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>    fmt.Println(p1 == p2)   <span class="hljs-comment">// 正常输出true，但添加func空字段后会编译报错</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>http.HandlerFunc</code>比<code>http.Handler</code>更好，<code>http.HandlerFunc</code>只需要一个 func，<code>http.Handler</code>需要一个类型</li><li><code>defer</code>移动至顶部，提高代码可靠性，并明确函数结束调用了什么</li><li>JS 解析整数为浮点数可能会导致 int64 溢出，使用<code>json:&quot;id,string&quot;</code></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Request <span class="hljs-keyword">struct</span> &#123;<br>    ID <span class="hljs-type">int64</span> <span class="hljs-string">`json:&quot;id,string&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-并发"><a href="#4-并发" class="headerlink" title="4. 并发"></a>4. 并发</h3><ul><li>以线程安全的方式创建单例（只创建一次）的最好选择是<code>sync.Once</code>，不要使用 flags、mutexes、channels or atomics</li><li>永远不要使用<code>select&#123;&#125;</code>，省略通道，等待信号 <span class="github-emoji" alias="question" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">&#x2753;</span></li><li>不要关闭一个发送（写入）通道，应该由创建者关闭（<span class="github-emoji" alias="warning" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png?v8">&#x26a0;</span>往一个关闭的 channel 里写数据会 panic）</li><li><code>math/rand</code>中的<code>func NewSource(seed int64) Source</code>不是并发安全的，默认的<code>lockedSource</code>是并发安全的<a href="https://github.com/golang/go/issues/3611"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a> or <a href="https://golang.org/pkg/math/rand/"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li><li>当你需要一个自定义类型的 aotmic 值时，你可以使用<code>atomic.Value</code></li></ul><h3 id="5-性能"><a href="#5-性能" class="headerlink" title="5. 性能"></a>5. 性能</h3><ul><li>不要省略<code>defer</code>，大多数情况下 200ns 加速可以忽略不计</li><li>总是关闭 http body，<code>defer r.Body.Close()</code>，除非你需要泄漏 goroutine</li><li>过滤不需要分配新内存</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang">b := a[:<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> a &#123;<br>    <span class="hljs-keyword">if</span> condition &#123;<br>        b = <span class="hljs-built_in">append</span>(b, x)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 为了帮助编译器删除绑定检查，参考`_ = b[7]`</span><br></code></pre></td></tr></table></figure><ul><li><code>time.Time</code>有指针字段<code>time.Location</code>并且这对 go GC 不好，只有使用了大量的<code>time.Time</code>对性能才有意义，否则使用 timestamp 代替</li><li><code>regexp.MustCompile</code>比<code>regexp.Compile</code>更好，大多数情况下，正则表达式是不可变的，所以你最好在<code>func init</code>中初始化它</li><li>请勿在你的热点代码中过度使用<code>fmt.Sprintf</code>，由于维护接口的缓冲池和动态调度，它是很昂贵的</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang">res := fmt.Sprintf(<span class="hljs-string">&quot;%s%s&quot;</span>, str1, str2)<br><span class="hljs-comment">// may be</span><br>res := str1 + str2<br><br>res = fmt.Sprintf(<span class="hljs-string">&quot;%x&quot;</span>,<span class="hljs-keyword">var</span>)<br><span class="hljs-comment">// may be</span><br>res = strconv.FormatInt(<span class="hljs-keyword">var</span>, <span class="hljs-number">16</span>)<br><br></code></pre></td></tr></table></figure><ul><li>如果你不需要它，可以考虑丢弃它，例如<code>io.Copy(ioutil.Discard, resp.Body)</code>，HTTP 客户端的传输不会重新连接，直到 body 被读完或关闭</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang">res, _ := client.Do(req)<br>io.Copy(ioutil.Discard, res.Body)<br><span class="hljs-keyword">defer</span> res.Body.Close()<br></code></pre></td></tr></table></figure><ul><li>不要在循环里使用 defer，否则会导致内存泄漏，因为这些 defer 会不断地填满你的栈（内存）</li><li>不要忘记停止 ticker，除非你需要泄漏 channel</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs golang">ticker := time.NewTicker(<span class="hljs-number">1</span> * time.Second)<br><span class="hljs-keyword">defer</span> ticker.Stop()<br></code></pre></td></tr></table></figure><ul><li>用自定义的 marshaler 去加速 marshal 过程，但是在使用它之前要进行定制！<a href="https://play.golang.org/p/SEm9Hvsi0r"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(entry Entry)</span></span> MarshalJSON() ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>    buffer := bytes.NewBufferString(<span class="hljs-string">&quot;&#123;&quot;</span>)<br>    first := <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> entry &#123;<br>        jsonValue, err := json.Marshal(value)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>        &#125;<br>        <span class="hljs-keyword">if</span> !first &#123;<br>            buffer.WriteString(<span class="hljs-string">&quot;,&quot;</span>)<br>        &#125;<br>        first = <span class="hljs-literal">false</span><br>        buffer.WriteString(key + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-type">string</span>(jsonValue))<br>    &#125;<br>    buffer.WriteString(<span class="hljs-string">&quot;&#125;&quot;</span>)<br>    <span class="hljs-keyword">return</span> buffer.Bytes(), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>sync.Map</code>是万能的，没有过硬的理由就要不使用它 <a href="https://github.com/golang/go/blob/master/src/sync/map.go#L12"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li><li>在<code>sync.Pool</code>中分配内存存储非指针数据 <a href="https://github.com/dominikh/go-tools/blob/master/cmd/staticcheck/docs/checks/SA6002"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li><li>为了隐藏逃生分析的指针，你可以小心使用这个函数 <a href="https://go-review.googlesource.com/c/go/+/86976"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// noescape hides a pointer from escape analysis.  noescape is</span><br><span class="hljs-comment">// the identity function but escape analysis doesn&#x27;t think the</span><br><span class="hljs-comment">// output depends on the input. noescape is inlined and currently</span><br><span class="hljs-comment">// compiles down to zero instructions.</span><br><span class="hljs-comment">//go:nosplit</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">noescape</span><span class="hljs-params">(p unsafe.Pointer)</span></span> unsafe.Pointer &#123;<br>    x := <span class="hljs-type">uintptr</span>(p)<br>    <span class="hljs-keyword">return</span> unsafe.Pointer(x ^ <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对于最快的原子交换，你可以使用<code>m := (*map[int]int)(atomic.LoadPointer(&amp;ptr))</code> <span class="github-emoji" alias="question" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">&#x2753;</span></li><li>如果执行许多顺序读取或写入操作，请使用缓冲 I&#x2F;O，以减少系统调用次数</li><li>两种清空一个 map 的方法</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 重用map内存（但是也要注意m的回收）</span><br><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> m &#123;<br>    <span class="hljs-built_in">delete</span>(m, k)<br>&#125;<br><br><span class="hljs-comment">// 给m分配新的内存</span><br>m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><h3 id="6-模块"><a href="#6-模块" class="headerlink" title="6. 模块"></a>6. 模块</h3><ul><li>如果你想在 CI 中测试<code>go.mod</code>和<code>go.sum</code>是否是最新<a href="https://blog.urth.org/2019/08/13/testing-go-mod-tidiness-in-ci/"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li></ul><h3 id="7-构建"><a href="#7-构建" class="headerlink" title="7. 构建"></a>7. 构建</h3><ul><li>用<code>go build -ldflags=&quot;-s -w&quot; ...</code>去掉你的二进制文件</li><li>拆分构建不同版本的简单方法，用<code>// + build integration</code>并且运行他们<code>go test -v --tags integration</code></li><li>构建最小的 Go Docker 镜像<a href="https://twitter.com/bbrodriges/status/873414658178396160"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">CGO_ENABLED=0 go build -ldflags=&quot;-s -w&quot; app.go &amp;&amp; tar C app | docker import - myimage:latest<br></code></pre></td></tr></table></figure><ul><li>run go format on CI and compare diff，确保一切都是生成的和承诺的</li><li>用最新的 Go 运行 Travis-CI，用<code>travis 1</code> <a href="https://github.com/travis-ci/travis-build/blob/master/public/version-aliases/go.json"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li><li>检查代码格式是否有错误<code>diff -u &lt;(echo -n) &lt;(gofmt -d .)</code></li></ul><h3 id="8-测试"><a href="#8-测试" class="headerlink" title="8. 测试"></a>8. 测试</h3><ul><li>测试名称<code>package_test</code>比<code>package</code>要好</li><li><code>go test -short</code>允许减少要运行的测试数</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSomething</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> testing.Short() &#123;<br>        t.Skip(<span class="hljs-string">&quot;skipping test in short mode.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>根据系统架构跳过测试</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">if</span> runtime.GOARM == <span class="hljs-string">&quot;arm&quot;</span> &#123;<br>    t.Skip(<span class="hljs-string">&quot;this doesn&#x27;t work under ARM&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>用<code>testing.AllocPerRun</code>跟踪你的内存分配<a href="https://godoc.org/testing#AllocsPerRun"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li><li>多次运行你的基准测试可以避免噪音<code>go test -test.bench=. -count=20</code></li></ul><h3 id="9-工具"><a href="#9-工具" class="headerlink" title="9. 工具"></a>9. 工具</h3><ul><li>快速替换<code>gofmt -w -l -r &quot;panic(err) -&gt; log.Error(err)&quot;</code>.</li><li><code>go list</code>允许找到所有直接和传递的依赖关系<ul><li><code>go list -f &#39;&#123;&#123; .Imports &#125;&#125;&#39; package</code>列出 package 中引入的包</li><li><code>go list -f &#39;&#123;&#123; .Deps &#125;&#125;&#39; package</code>列出 package 中所有包的信息</li></ul></li><li>对于快速基准比较，<a href="https://godoc.org/golang.org/x/perf/cmd/benchstat"><code>benchstat</code></a></li><li><code>go-critic</code> linter，从这个文件中强制执行几条建议</li><li><code>go mod why -m &lt;module&gt;</code>告诉我们为什么特定的模块在<code>go.mod</code>文件中。</li><li><code>GOGC=off go build ...</code>应该会加快构建速度<a href="https://twitter.com/mvdan_/status/1107579946501853191"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li><li>内存分析器每 512KB 记录一次分配。你能通过<code>GODEBUG</code>环境变量增加比例，来查看你的文件的更多详细信息<a href="https://twitter.com/bboreham/status/1105036740253937664"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li></ul><h3 id="10-其它"><a href="#10-其它" class="headerlink" title="10. 其它"></a>10. 其它</h3><ul><li>dump goroutines <a href="https://stackoverflow.com/a/27398062/433041"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    sigs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">1</span>)<br>    signal.Notify(sigs, syscall.SIGQUIT)<br>    buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>)<br>    <span class="hljs-keyword">for</span> &#123;<br>        &lt;-sigs<br>        stacklen := runtime.Stack(buf, <span class="hljs-literal">true</span>)<br>        log.Printf(<span class="hljs-string">&quot;=== received SIGQUIT ===\n*** goroutine dump...\n%s\n*** end\n&quot;</span>  , buf[:stacklen])<br>    &#125;<br>&#125;()<br></code></pre></td></tr></table></figure><ul><li>在编译期检查接口的实现</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> _ io.Reader = (*MyFastReader)(<span class="hljs-literal">nil</span>)<br></code></pre></td></tr></table></figure><ul><li><code>len(nil) = 0</code> <a href="https://golang.org/pkg/builtin/#len"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li><li>匿名结构体很好用</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> hits <span class="hljs-keyword">struct</span> &#123;<br>    sync.Mutex<br>    n <span class="hljs-type">int</span><br>&#125;<br>hits.Lock()<br>hits.n++<br>hits.Unlock()<br></code></pre></td></tr></table></figure><ul><li><code>httputil.DumpRequest</code>是非常有用的东西，不要自己创建<a href="https://godoc.org/net/http/httputil#DumpRequest"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li><li>获得调用堆栈，可以使用<code>runtime.Caller</code> <a href="https://golang.org/pkg/runtime/#Caller"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a></li><li>要 marshal 未知的 JSON，你可以 marshal 为<code>map[string]interface&#123;&#125;</code></li><li>从一个 slice 生成简单的随机元素</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs golang">[]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>&#125;[rand.Intn(<span class="hljs-number">3</span>)]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Arch旅行第一集-安装Arch</title>
    <link href="/20220617/archlinux-installation/"/>
    <url>/20220617/archlinux-installation/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>安装 ArchLinux，起因是因为我的这台 XiaoMI Air13 老古董，在 windows 环境下跑个 IDEA 卡的不行，严重影响编程效率，而且只有 8G 内存，实在是不想把内存分配给一些无用的程序。<br>起初对于系统的了解是皮毛的皮毛，所以没有选择裸机安装。当然，我也没有用虚拟机测试，因为我的硬盘也不够用，所以我起初选择的是<a href="https://manjaro.org/download/">Manjaro + i3wm </a> 的组合安装镜像，不用输入命令，有安装引导界面，很适合新手使用。当然还有跟多炫酷桌面管理，比如 GNOME、PLASMA、XFCE 等，我选择 i3 的理由是内存占用小。慢慢的我也喜欢上了平铺式窗口管理器。有需要的进入后面的链接观看。<a href="https://manjaro.org/download/"><span class="github-emoji" alias="link" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8">&#x1f517;</span></a><br>Manjaro 的配置可以说相当完善，相对于 Arch 稳定了不少（插句嘴，Manjaro 是 Arch 的衍生版），我也用了一段时间，但是后面就会有些小问题，Manjaro 的 Wiki 相对于 Arch 比较差，所以每次有问题就会去 ArchWiki 中寻找解决方法，但是许多相同的问题并不能得到结局。半年后我还是选择重装了 Arch 系统。<br>不想听我逼逼赖赖的同学可以去<a href="https://www.bilibili.com/video/BV11J411a7Tp">最全 Arch Linux 安装教程——打造真正属于你的操作系统</a>，这个老哥的视频相当到位，配合弹幕食用更佳。</p><span id="more"></span><h3 id="准备镜像"><a href="#准备镜像" class="headerlink" title="准备镜像"></a>准备镜像</h3><ol><li>你需要一个 U 盘，1~2G 就足够了。因为要将镜像文件写入 U 盘，你需要将 U 盘中有用的信息文件拷贝出来。</li><li>下载镜像以及写盘工具。<a href="https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/2022.12.01/archlinux-2022.12.01-x86_64.iso">ArchLinux</a>，如果下载太慢，可在<a href="https://archlinux.org/download/">Arch Linux Download</a>中找到 China 的非清华源的镜像网站下载。写盘工具<a href="https://github.com/pbatard/rufus/archive/v3.21.zip">rufus</a>。</li><li>打开 rufus，Device 选择 U 盘，Boot Selection 选择 Arch ISO 文件，其他默认,Start 待写入完成即可。</li></ol><h3 id="USB-启动"><a href="#USB-启动" class="headerlink" title="USB 启动"></a>USB 启动</h3><p>上网查询主板的开机启动项快捷键，像我这台 XiaoMI Air13 是 F12，先插入 U 盘，再进入启动项管理，如果没有发现 U 盘，进去 BIOS 面板，打开 USB Boot，再进入启动项管理，选择 U 盘启动。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Arch</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
